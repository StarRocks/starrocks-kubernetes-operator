
# This file is generated by scripts/create-parent-chart-values.sh.
# It just contains the values of the child charts.
# You can modify it manually if you want to change the values of the child charts.
# The values of the child charts are as follows:

operator:
  # Default values for operator.
  # This is a YAML-formatted file.
  # Declare variables to be passed into your templates.
  
  global:
    rbac:
      # if set true, the clusterrole, clusterrolebinding, role, rolebinding, serviceaccount resources will be created for
      # operator. If changed to false later, these resources will be deleted.
      create: true
      serviceAccount:
        name: "starrocks"
        # Optional annotations to add to serviceaccount manifest
        annotations: {}
        # Optional labels to add to serviceaccount manifest
        labels: {}
  
  # TimeZone is used to set the environment variable TZ for pod, with Asia/Shanghai as the default.
  timeZone: Asia/Shanghai
  
  # set the nameOverride values for creating the same resources with parent chart.
  # In version v1.7.1 or before, there is only one chart called kube-starrocks, and the chart name is the prefix
  # of some resources created by the chart.
  # In version v1.8.0, the kube-starrocks chart is split into two charts, and to keep backward compatibility, the
  # nameOverride is used to set the prefix of the resources created by operator chart.
  nameOverride: "kube-starrocks"
  
  starrocksOperator:
    enabled: true
    # annotations for starrocks operator.
    annotations: {}
    namespaceOverride: ""
    image:
      # image sliced by "repository:tag"
      repository: starrocks/operator
      tag: v1.9.2
    imagePullPolicy: Always
    replicaCount: 1
    resources:
      limits:
        cpu: 500m
        memory: 800Mi
      requests:
        cpu: 500m
        memory: 400Mi
    # imagePullSecrets allows you to use secrets to pull images for pods.
    imagePullSecrets: []
    # - name: "image-pull-secret"
    # If specified, the pod's nodeSelector，displayName="Map of nodeSelectors to match when scheduling pods on nodes"
    # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}
    # affinity for operator pod scheduling.
    affinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchFields:
      #       - key: metadata.name
      #         operator: In
      #         values:
      #         - target-host-name
    tolerations: []
      # - key: "key"
      #   operator: "Equal|Exists"
      #   value: "value"
      #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
    # If specified, it will restrict operator to watch resources in the specified namespace. And
    #  1. You must deploy your StarRocks cluster to the specified namespace.
    #  2. You can not assign multiple namespaces to watchNamespace field.
    # Note: In most cases, you should not set this value. If your kubernetes cluster manages too many nodes, and
    # operator watching all namespaces use too many memory resources, you can set this value.
    # Defaults to all namespaces.
    watchNamespace: ""
    # Additional operator container environment variables
    # You specify this manually like you would a raw deployment manifest.
    # Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/
    # operator supports the following environment variables:
    # KUBE_STARROCKS_UNSUPPORTED_ENVS: "XXX,YYY" # The environment variables that will not be passed to starrocks container.
    env: []
    # setting log related parameter
    log:
      - --zap-time-encoding=iso8601
      - --zap-encoder=console
      # if you want open debug log, open this option
      # - --zap-log-level 4

starrocks:
  # set the nameOverride values for creating the same resources with parent chart.
  # In version v1.7.1 or before, there is only one chart called kube-starrocks, and the chart name is the prefix
  # of some resources created by the chart.
  # In version v1.8.0, the kube-starrocks chart is split into two charts, and to keep backward compatibility, the
  # nameOverride is used to set the prefix of the resources created by starrocks chart.
  nameOverride: "kube-starrocks"
  
  # This configuration is used to modify the root password during initial deployment.
  # After deployment is completed, it won't take effect to modify the password here and to do a `helm upgrade`.
  # It also supports providing secret name that contains password, using the password in the secret instead of the plaintext in the values.yaml.
  # When both password and passwordSecret are set, only passwordSecret takes effect.
  # Note: If you install StarRocks using helm install without setting the initPassword, then for subsequent upgrade deployments,
  #       you should also not set the initPassword.
  #       If you install StarRocks using helm install and set the initPassword, please always retain the configuration of initPassword.
  initPassword:
    enabled: false
    password: ""
    # The secret name that contains password, the key of the secret is "password", and you should create it first.
    passwordSecret: ""
  
  # TimeZone is used to set the environment variable TZ for pod, with Asia/Shanghai as the default.
  timeZone: Asia/Shanghai
  
  # This configuration is used to integrate with external system DataDog.
  # You can enable the integration by setting the enabled to true, e.g. datalog.log.enabled=true will enable datadog agent
  # to collect the log.
  datadog:
    log:
      enabled: false
      # besides the attributes you added, chart will append "source" and "service" attributes to the log config.
      # see https://docs.datadoghq.com/containers/kubernetes/log/?tab=operator for more details.
      logConfig: '{}' # e.g. '{"app": "starrocks", "tags": ["aa", "bb"]}'
    metrics:
      enabled: false
    profiling:
      fe: false # change to 'true' to enable profiling on FE pods;
      be: false # change to 'true' to enable profiling on BE pods;
      cn: false # change to 'true' to enable profiling on CN pods;
      env: "starrocks-default" # the default value for DD_ENV;
  
  # This configuration is used to integrate with external system Prometheus.
  metrics:
    serviceMonitor:
      # Whether to expose metrics to Prometheus by ServiceMonitor.
      # Note: make sure the prometheus operator is installed in your cluster.
      # If prometheus is not installed by operator, you can add annotations on k8s service to expose metrics.
      # see https://github.com/StarRocks/starrocks-kubernetes-operator/blob/main/doc/integration/integration-prometheus-grafana.md#51-turn-on-the-prometheus-metrics-scrape-by-adding-annotations for more details.
      enabled: false
      # Prometheus ServiceMonitor labels
      labels: {}
        # scraper: prometheus-operator
      # Prometheus ServiceMonitor interval
      interval: 15s
  
  # deploy a starrocks cluster
  starrocksCluster:
    # the name of starrockscluster cluster, if not set, the value of nameOverride fields will be used.
    name: ""
    # the namespace of starrockscluster cluster, if not set, the release namespace will be used.
    namespace: ""
    # annotations for starrocks cluster.
    annotations: {}
    # specify the cn deploy or not.
    enabledBe: true
    enabledCn: false
    # componentValues field is used to define values for all starrocks cluster components, including starrocksFESpec,
    # starrocksBeSpec, starrocksCnSpec, not including starrocksFeProxySpec. So that you do not need to modify them in
    # their own spec.
    # Note:
    #   1. the values in their own spec will take precedence over the values in this field.
    #   2. the values in their own spec will replace all the values in this field, not merge.
    componentValues:
      image:
        tag: "3.1-latest"
      # hostAliases allows adding entries to /etc/hosts inside the containers.
      hostAliases: []
        # - ip: "127.0.0.1"
        #   hostnames:
        #   - "example.com"
      # If runAsNonRoot is true, the container is run as non-root user.
      # The userId will be set to 1000, and the groupID will be set to 1000.
      runAsNonRoot: false
      # schedulerName allows you to specify which scheduler will be used for your pods.
      schedulerName: ""
      # serviceAccount for access cloud service.
      serviceAccount: ""
      # imagePullSecrets allows you to use secrets to pull images for pods.
      imagePullSecrets: []
      # - name: "image-pull-secret"
      # tolerations for pod scheduling to nodes with taints
      # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
      tolerations: []
        # - key: "key"
        #   operator: "Equal|Exists"
        #   value: "value"
        #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
      # If specified, the pod's nodeSelector，displayName="Map of nodeSelectors to match when scheduling pods on nodes"
      # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
      nodeSelector: {}
        # kubernetes.io/arch: amd64
        # kubernetes.io/os: linux
      # affinity for pod scheduling.
      affinity: {}
        # nodeAffinity:
        #   requiredDuringSchedulingIgnoredDuringExecution:
        #     nodeSelectorTerms:
        #     - matchFields:
        #       - key: metadata.name
        #         operator: In
        #         values:
        #         - target-host-name
      # the pod labels for user select or classify pods.
      podLabels: {}
  
  # spec to deploy fe.
  starrocksFESpec:
    # number of replicas to deploy for a fe statefulset.
    replicas: 1
    image:
      # image sliced by "repository:tag"
      repository: starrocks/fe-ubuntu
      tag: ""
    # add annotations for fe pods. For example, if you want to config monitor for datadog, you can config the annotations.
    annotations: {}
    # If runAsNonRoot is true, the container is run as non-root user.
    # The userId will be set to 1000, and the groupID will be set to 1000.
    runAsNonRoot: false
    # specify the service name and port config and serviceType
    # the service type refer https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    service:
      # the fe service type, only supported ClusterIP, NodePort, LoadBalancer
      type: "ClusterIP"
      # the loadBalancerIP for static ip config when the type=LoadBalancer and loadbalancerIp is not empty.
      loadbalancerIP: ""
      # add annotations for fe service.
      annotations: {}
      # config the service port for fe service.
      # To assign a specific port or nodePort to a service, you should specify them by the corresponding name or
      # containerPort in the service configuration. If both containerPort and name are specified, containerPort takes precedence.
      # For fe, port name can be http, query, rpc, edit-log, and their default container port is 8030, 9030, 9020, 9010.
      ports: []
        # e.g. specify a dedicated node port for fe service by containerPort.
        # - nodePort: 30030 # The range of valid ports is 30000-32767
        #   containerPort: 8030 # The port exported on the container
    # imagePullSecrets allows you to use secrets to pull images for pods.
    imagePullSecrets: []
      # - name: "image-pull-secret"
    # serviceAccount for fe access cloud service.
    serviceAccount: ""
    # If specified, the pod's nodeSelector，displayName="Map of nodeSelectors to match when scheduling pods on nodes"
    # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}
      # kubernetes.io/arch: amd64
      # kubernetes.io/os: linux
    # the pod labels for user select or classify pods.
    podLabels: {}
    # hostAliases allows adding entries to /etc/hosts inside the containers
    hostAliases: []
      # - ip: "127.0.0.1"
      #   hostnames:
      #   - "example.com"
    # schedulerName allows you to specify which scheduler will be used for your pods.
    schedulerName: ""
    # Additional fe container environment variables.
    # See https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/ for how to define environment variables.
    # Note: If you use slice to define environment variables, and if there are multiple values files, the values in the last values file will take effect.
    #       If you use map to define environment variables, the values in the values files will be merged.
    #       You can only use one of slice and map to define environment variables.
    # In order to avoid different type of feEnvVars, we do not define the default value of feEnvVars, e.g. feEnvVars: [] or feEnvVars: {}.
    #feEnvVars:
      # define environment variables by slice.
      # e.g. static environment variable:
      # - name: DEMO_GREETING
      #   value: "Hello from the environment"
      # e.g. secret environment variable:
      # - name: USERNAME
      #   valueFrom:
      #     secretKeyRef:
      #       name: mysecret
      #       key: username
    # affinity for fe pod scheduling.
    affinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchFields:
      #       - key: metadata.name
      #         operator: In
      #         values:
      #         - target-host-name
    # Node tolerations for fe pod scheduling to nodes with taints
    # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    tolerations: []
      # - key: "key"
      #   operator: "Equal|Exists"
      #   value: "value"
      #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
    # resources for fe pod.
    resources:
      requests:
        cpu: 4
        memory: 4Gi
      # If you want to remove one resource limit, e.g. cpu, you can it to cpu: "unlimited".
      limits:
        cpu: 8
        memory: 8Gi
    # fe storageSpec for persistent metadata.
    # Note: Once set, the following fields will not be allowed to be modified.
    storageSpec:
      name: ""
      # the storageClassName represent the used storageclass name. if not set will use k8s cluster default storageclass.
      # you must set name when you set storageClassName
      storageClassName: ""
      # the persistent volume size， default 10Gi.
      # fe container stop running if the disk free space which the fe meta directory residents, is less than 5Gi.
      storageSize: 10Gi
      # If storageMountPath is empty, the storageMountPath will be set to /opt/starrocks/fe/meta.
      storageMountPath: ""
      # Setting this parameter can persist log storage, and the mount path is /opt/starrocks/fe/log.
      # If you set it to 0Gi, the related PVC will not be created, and the log will not be persisted.
      logStorageSize: 5Gi
    # mount other volumes if necessary.
    # Note: please use storageSpec field for persistent metadata and log.
    emptyDirs: []
      # e.g. mount an emptyDir volume to /tmp
      # - name: tmp-data
      #   mountPath: /tmp
    # the config for start fe. the base information as follows.
    config: |
      LOG_DIR = ${STARROCKS_HOME}/log
      DATE = "$(date +%Y%m%d-%H%M%S)"
      JAVA_OPTS="-Dlog4j2.formatMsgNoLookups=true -Xmx8192m -XX:+UseMembar -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=7 -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -Xloggc:${LOG_DIR}/fe.gc.log.$DATE"
      JAVA_OPTS_FOR_JDK_9="-Dlog4j2.formatMsgNoLookups=true -Xmx8192m -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=7 -XX:+CMSClassUnloadingEnabled -XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -Xlog:gc*:${LOG_DIR}/fe.gc.log.$DATE:time"
      JAVA_OPTS_FOR_JDK_11="-Dlog4j2.formatMsgNoLookups=true -Xmx8192m -XX:+UseG1GC -Xlog:gc*:${LOG_DIR}/fe.gc.log.$DATE:time"
      http_port = 8030
      rpc_port = 9020
      query_port = 9030
      edit_log_port = 9010
      mysql_service_nio_enabled = true
      sys_log_level = INFO
    # mount secrets if necessary.
    # see https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath for more details about subPath.
    secrets: []
      # e.g. mount my-secret to /etc/my-secret
      # - name: my-secret
      #   mountPath: /etc/my-secret
      #   subPath: ""
    # mount configmaps if necessary.
    # see https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath for more details about subPath.
    configMaps: []
      # e.g. mount my-configmap to /etc/my-configmap
      # - name: my-configmap
      #   mountPath: /etc/my-configmap
      #   subPath: ""
    # terminationGracePeriodSeconds defines duration in seconds the FE pod needs to terminate gracefully.
    # default value is 120 seconds
    terminationGracePeriodSeconds: 120
  
    # Please upgrade the CRD with v1.8.7 released version, if you want to use the following configuration.
    # including: startupProbeFailureSeconds, livenessProbeFailureSeconds, readinessProbeFailureSeconds
  
    # StartupProbeFailureSeconds defines the total failure seconds of startup Probe.
    # default value is 300 seconds
    startupProbeFailureSeconds:
    # LivenessProbeFailureSeconds defines the total failure seconds of liveness Probe.
    # default value is 15 seconds
    livenessProbeFailureSeconds:
    # ReadinessProbeFailureSeconds defines the total failure seconds of readiness Probe.
    # default value is 15 seconds
    readinessProbeFailureSeconds:
  
  # spec for compute node, compute node provide compute function.
  starrocksCnSpec:
    # number of replicas to deploy for cn component.
    # In the implementation of the operator: Even when both the replicas and autoScalingPolicy are set in the starrocksCnSpec
    # field, the replicas field of the cn statefulset created by the operator will be set to null. This ensures that the replicas
    # field is controlled by HPA. Next, if a user's deployment, for example, does not involve changes to CN, then the pods
    # of Cn will not be recreated.
    # Why should the replicas field in this values.yaml be set to null? This is the default replicas. When the user removes
    # the autoScalingPolicy fields from the starrocksCnSpec, the corresponding HPA object will be deleted. And when the replicas
    # field is set, the number of pods will immediately revert to the replicas count, even though the user did not specify
    # the replicas count in their own values.yaml.
    # replicas: 1
    image:
      # image sliced by "repository:tag"
      repository: starrocks/cn-ubuntu
      tag: ""
    # serviceAccount for cn access cloud service.
    serviceAccount: ""
    # add annotations for cn pods. example, if you want to config monitor for datadog, you can config the annotations.
    annotations: {}
    # If runAsNonRoot is true, the container is run as non-root user.
    # The userId will be set to 1000, and the groupID will be set to 1000.
    runAsNonRoot: false
    # add/drop capabilities for CN container.
    capabilities: {}
    #  add:
    #    - PERFMON
    #    - SYS_PTRACE
    #  drop:
    #    - SYS_ADMIN
    # specify the service name and port config and serviceType
    # the service type refer https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    service:
      # the cn service type, only supported ClusterIP, NodePort, LoadBalancer
      type: "ClusterIP"
      # the loadBalancerIP for static ip config when the type=LoadBalancer and loadBalancerIp is not empty.
      loadbalancerIP: ""
      # add annotations for cn service.
      annotations: {}
      # config the service port for cn service.
      # To assign a specific port or nodePort to a service, you should specify them by the corresponding name or
      # containerPort in the service configuration. If both containerPort and name are specified, containerPort takes precedence.
      # For cn, port name can be webserver, heartbeat, brpc, thrift, and their default container port is 8040, 9050, 8060, 9060.
      ports: []
        # e.g. specify a dedicated node port for cn service by containerPort.
        # - nodePort: 30040 # The range of valid ports is 30000-32767
        #   containerPort: 8040 # The port on the container to expose
    # imagePullSecrets allows you to use secrets for pulling images for your pods.
    imagePullSecrets: []
      # - name: "image-pull-secret"
    # If specified, the pod's nodeSelector，displayName="Map of nodeSelectors to match when scheduling pods on nodes"
    # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}
      # kubernetes.io/arch: amd64
      # kubernetes.io/os: linux
    # the pod labels for user select or classify pods.
    podLabels: {}
    ## hostAliases allows adding entries to /etc/hosts inside the containers
    hostAliases: []
      # - ip: "127.0.0.1"
      #   hostnames:
      #   - "example.com"
    # schedulerName allows you to specify which scheduler will be used for the pod
    schedulerName: ""
    # Additional cn container environment variables.
    # See https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/ for how to define environment variables.
    # Note: If you use slice to define environment variables, and if there are multiple values files, the values in the last values file will take effect.
    #       If you use map to define environment variables, the values in the values files will be merged.
    #       You can only use one of slice and map to define environment variables.
    # In order to avoid different type of cnEnvVars, we do not define the default value of cnEnvVars, e.g. cnEnvVars: [] or cnEnvVars: {}.
    # cnEnvVars:
      # define environment variables by slice.
      # e.g. static environment variable:
      # - name: DEMO_GREETING
      #   value: "Hello from the environment"
      # e.g. secret environment variable:
      # - name: USERNAME
      #   valueFrom:
      #     secretKeyRef:
      #       name: mysecret
      #       key: username
    # affinity for cn pod scheduling.
    affinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #       - matchFields:
      #           - key: metadata.name
      #             operator: In
      #             values:
      #               - target-host-name
    # Node tolerations for cn pod scheduling to nodes with taints
    # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    tolerations: []
      # - key: "key"
      #   operator: "Equal|Exists"
      #   value: "value"
      #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
    autoScalingPolicy: {}
      # you can select different versions of HPA (Horizontal Pod Autoscaler) based on the Kubernetes version you are
      # using to ensure compatibility and adaptability. the default version is v2beta2.
      # version: v2beta2
      # maxReplicas: 10
      # minReplicas: 1
      # hpaPolicy:
      #   metrics:
      #   - type: Resource
      #     resource:
      #       name: memory
      #       target:
      #         averageUtilization: 30
      #         type: Utilization
      #   - type: Resource
      #     resource:
      #       name: cpu
      #       target:
      #         averageUtilization: 30
      #         type: Utilization
      #   behavior:
      #     scaleUp:
      #       policies:
      #       - type: Pods
      #         value: 1
      #         periodSeconds: 10
      #     scaleDown:
      #       selectPolicy: Disabled
    # define resources requests and limits for cn pods.
    resources:
      # If you want to remove one resource limit, e.g. cpu, you can it to cpu: "unlimited".
      limits:
        cpu: 8
        memory: 8Gi
      requests:
        cpu: 4
        memory: 8Gi
    # specify storageclass name and request size.
    # Note: Once set, the following fields will not be allowed to be modified.
    storageSpec:
      # the name of volume for mount. if not will use emptyDir.
      name: ""
      # the storageClassName represent the used storageclass name. if not set will use k8s cluster default storageclass.
      # you must set name when you set storageClassName
      storageClassName: ""
      # the storage size of persistent volume for data.
      storageSize: 1Ti
      # If storageMountPath is empty, the storageMountPath will be set to /opt/starrocks/cn/storage.
      storageMountPath: ""
      # the storage size of persistent volume for log, and the mount path is /opt/starrocks/cn/log.
      # If you set it to 0Gi, the related PVC will not be created, and the log will not be persisted.
      logStorageSize: 1Gi
    # mount other volumes if necessary.
    # Note: please use storageSpec field for persistent storage data and log.
    emptyDirs: []
      # e.g. mount an emptyDir volume to /tmp
      # - name: tmp-data
      #   mountPath: /tmp
    # the config start for cn, the base information as follows.
    config: |
      sys_log_level = INFO
      # ports for admin, web, heartbeat service
      thrift_port = 9060
      webserver_port = 8040
      heartbeat_service_port = 9050
      brpc_port = 8060
    # mount secrets if necessary.
    # see https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath for more details about subPath.
    secrets: []
      # e.g. mount my-secret to /etc/my-secret
      # - name: my-secret
      #   mountPath: /etc/my-secret
      #   subPath: ""
    # mount configmaps if necessary.
    # see https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath for more details about subPath.
    configMaps: []
      # e.g. mount my-configmap to /etc/my-configmap
      # - name: my-configmap
      #   mountPath: /etc/my-configmap
      #   subPath: ""
    # terminationGracePeriodSeconds defines duration in seconds the CN pod needs to terminate gracefully.
    # default value is 120 seconds
    terminationGracePeriodSeconds: 120
  
    # Please upgrade the CRD with v1.8.7 released version, if you want to use the following configuration.
    # including: startupProbeFailureSeconds, livenessProbeFailureSeconds, readinessProbeFailureSeconds
  
    # StartupProbeFailureSeconds defines the total failure seconds of startup Probe.
    # default value is 300 seconds
    startupProbeFailureSeconds:
    # LivenessProbeFailureSeconds defines the total failure seconds of liveness Probe.
    # default value is 15 seconds
    livenessProbeFailureSeconds:
    # ReadinessProbeFailureSeconds defines the total failure seconds of readiness Probe.
    # default value is 15 seconds
    readinessProbeFailureSeconds:
  
  # spec for component be, provide storage and compute function.
  starrocksBeSpec:
    # number of replicas to deploy.
    replicas: 1
    image:
      # image sliced by "repository:tag"
      repository: starrocks/be-ubuntu
      tag: ""
    # serviceAccount for be access cloud service.
    serviceAccount: ""
    # add annotations for be pods. example, if you want to config monitor for datadog, you can config the annotations.
    annotations: {}
    # If runAsNonRoot is true, the container is run as non-root user.
    # The userId will be set to 1000, and the groupID will be set to 1000.
    runAsNonRoot: false
    # add/drop capabilities for BE container.
    capabilities: {}
    #  add:
    #    - PERFMON
    #    - SYS_PTRACE
    #  drop:
    #    - SYS_ADMIN
    # specify the service name and port config and serviceType
    # the service type refer https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    service:
      # the be service type, only supported ClusterIP, NodePort, LoadBalancer
      type: "ClusterIP"
      # the loadBalancerIP for static ip config when the type=LoadBalancer and loadbalancerIp is not empty.
      loadbalancerIP: ""
      # add annotations for be service.
      annotations: {}
      # config the service port for be service.
      # To assign a specific port or nodePort to a service, you should specify them by the corresponding name or
      # containerPort in the service configuration. If both containerPort and name are specified, containerPort takes precedence.
      # For be, port name can be webserver, heartbeat, brpc, be, and their default container port is 8040, 9050, 8060, 9060.
      ports: []
        # e.g. specify a dedicated node port for be service by containerPort.
        # - nodePort: 30040 # The range of valid ports is 30000-32767
        #   containerPort: 8040 # The port on the container to expose
    # imagePullSecrets allows you to use secrets to pull images for pods.
    imagePullSecrets: []
      # - name: "image-pull-secret"
    # If specified, the pod's nodeSelector，displayName="Map of nodeSelectors to match when scheduling pods on nodes"
    # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}
      # kubernetes.io/arch: amd64
      # kubernetes.io/os: linux
    # the pod labels for user select or classify pods.
    podLabels: {}
    ## hostAliases allows adding entries to /etc/hosts inside the containers
    hostAliases: []
      # - ip: "127.0.0.1"
      #   hostnames:
      #   - "example.com"
    # schedulerName allows you to specify which scheduler will be used for the pod
    schedulerName: ""
    # Additional be container environment variables.
    # See https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/ for how to define environment variables.
    # Note: If you use slice to define environment variables, and if there are multiple values files, the values in the last values file will take effect.
    #       If you use map to define environment variables, the values in the values files will be merged.
    #       You can only use one of slice and map to define environment variables.
    # In order to avoid different type of beEnvVars, we do not define the default value of beEnvVars, e.g. beEnvVars: [] or beEnvVars: {}.
    # beEnvVars:
      # define environment variables by slice.
      # e.g. static environment variable:
      # - name: DEMO_GREETING
      #   value: "Hello from the environment"
      # e.g. secret environment variable:
      # - name: USERNAME
      #   valueFrom:
      #     secretKeyRef:
      #       name: mysecret
      #       key: username
    # affinity for fe pod scheduling.
    affinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchFields:
      #       - key: metadata.name
      #         operator: In
      #         values:
      #         - target-host-name
    # Node tolerations for be pod scheduling to nodes with taints
    # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    tolerations: []
      # - key: "key"
      #   operator: "Equal|Exists"
      #   value: "value"
      #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
    # resources for be pod.
    resources:
      requests:
        cpu: 4
        memory: 4Gi
      # If you want to remove one resource limit, e.g. cpu, you can it to cpu: "unlimited".
      limits:
        cpu: 8
        memory: 8Gi
    # be storageSpec for persistent storage.
    # Note: Once set, the following fields will not be allowed to be modified.
    storageSpec:
      # the name of volume for mount. if not will use emptyDir.
      name: ""
      # the storageClassName represent the used storageclass name. if not set will use k8s cluster default storageclass.
      # you must set name when you set storageClassName
      storageClassName: ""
      # the storage size of persistent volume for data.
      storageSize: 1Ti
      # If storageMountPath is empty, the storageMountPath will be set to /opt/starrocks/be/storage.
      storageMountPath: ""
      # Setting this parameter can persist log storage, and the mount path is /opt/starrocks/be/log.
      # If you set it to 0Gi, the related PVC will not be created, and the log will not be persisted.
      logStorageSize: 1Gi
    # mount other volumes if necessary.
    # Note: please use storageSpec field for persistent storage data and log.
    emptyDirs: []
      # e.g. mount an emptyDir volume to /tmp
      # - name: tmp-data
      #   mountPath: /tmp
    # the config for start be. the base information as follows.
    config: |
      be_port = 9060
      webserver_port = 8040
      heartbeat_service_port = 9050
      brpc_port = 8060
      sys_log_level = INFO
      default_rowset_type = beta
    # mount secrets if necessary.
    # see https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath for more details about subPath.
    secrets: []
      # e.g. mount my-secret to /etc/my-secret
      # - name: my-secret
      #   mountPath: /etc/my-secret
      #   subPath: ""
    # mount configmaps if necessary.
    # see https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath for more details about subPath.
    configMaps: []
      # e.g. mount my-configmap to /etc/my-configmap
      # - name: my-configmap
      #   mountPath: /etc/my-configmap
      #   subPath: ""
    # terminationGracePeriodSeconds defines duration in seconds the BE pod needs to terminate gracefully.
    # default value is 120 seconds
    terminationGracePeriodSeconds: 120
  
    # Please upgrade the CRD with v1.8.7 released version, if you want to use the following configuration.
    # including: startupProbeFailureSeconds, livenessProbeFailureSeconds, readinessProbeFailureSeconds
  
    # StartupProbeFailureSeconds defines the total failure seconds of startup Probe.
    # default value is 300 seconds
    startupProbeFailureSeconds:
    # LivenessProbeFailureSeconds defines the total failure seconds of liveness Probe.
    # default value is 15 seconds
    livenessProbeFailureSeconds:
    # ReadinessProbeFailureSeconds defines the total failure seconds of readiness Probe.
    # default value is 15 seconds
    readinessProbeFailureSeconds:
  
  # create secrets if necessary.
  secrets: []
    # e.g. create my-secret
    # - name: my-secret
    #   data:
    #     key: |
    #       this is the content of the secret
    #       when mounted, key will be the name of the file
  
  # create configmaps if necessary.
  configMaps: []
    # e.g. create my-configmap
    # - name: my-configmap
    #   data:
    #     key: |
    #       this is the content of the configmap
    #       when mounted, key will be the name of the file
  
  # specify the fe proxy deploy or not.
  starrocksFeProxySpec:
    # specify the fe proxy deploy or not.
    enabled: false
    replicas: 1
    # default nginx:1.24.0
    image:
      repository: ""
      tag: ""
    resources:
      limits:
        cpu: 1
        memory: 2Gi
      requests:
        cpu: 1
        memory: 2Gi
    # set the resolver for nginx server, default kube-dns.kube-system.svc.cluster.local
    resolver: ""
    service:
      # the fe proxy service type, only supported ClusterIP, NodePort, LoadBalancer
      # default ClusterIP
      type: ClusterIP
      # the loadBalancerIP for static ip config when the type=LoadBalancer and loadbalancerIp is not empty.
      loadbalancerIP: ""
      # config the service port for fe proxy service.
      # To assign a specific port or nodePort to a service, you should specify them by the corresponding name or
      # containerPort in the service configuration. If both containerPort and name are specified, containerPort takes precedence.
      # For fe proxy, port name can be http-port, and its default container port is 8080.
      ports: []
        # e.g. specify a dedicated node port for fe proxy service by containerPort.
        # - nodePort: 30080 # The range of valid ports is 30000-32767
        #   containerPort: 8080 # The port on the container to expose
    # imagePullSecrets allows you to use secrets for pulling images for your pods.
    imagePullSecrets: []
    # - name: "image-pull-secret"
    # If specified, the pod's nodeSelector，displayName="Map of nodeSelectors to match when scheduling pods on nodes"
    # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
    nodeSelector: {}
      # kubernetes.io/arch: amd64
      # kubernetes.io/os: linux
    # affinity for fe proxy pod scheduling.
    affinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchFields:
      #       - key: metadata.name
      #         operator: In
      #         values:
      #         - target-host-name
    # Node tolerations for fe proxy pod scheduling to nodes with taints
    # Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    tolerations: []
      # - key: "key"
      #   operator: "Equal|Exists"
      #   value: "value"
      #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"
  
    # Please upgrade the CRD with v1.8.7 released version, if you want to use the following configuration.
    # including: livenessProbeFailureSeconds, readinessProbeFailureSeconds
  
    # LivenessProbeFailureSeconds defines the total failure seconds of liveness Probe.
    # default value is 15 seconds
    livenessProbeFailureSeconds:
    # ReadinessProbeFailureSeconds defines the total failure seconds of readiness Probe.
    # default value is 15 seconds
    readinessProbeFailureSeconds:
    # Note: will create emptyDir volume for fe proxy, PVC is not supported.
    emptyDirs: []
        # e.g. mount an emptyDir volume to /tmp
        # - name: tmp-data
        #   mountPath: /tmp
